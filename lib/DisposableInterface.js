"use strict";function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;},_typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});Object.defineProperty(subClass,"prototype",{writable:false});if(superClass)_setPrototypeOf(subClass,superClass);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}else if(call!==void 0){throw new TypeError("Derived constructors may only return object or undefined");}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}var os=require('os');var dgram=require('dgram');var NetworkInterface=require('./NetworkInterface');var filename=require('path').basename(__filename);var debug=require('./debug')("dnssd:".concat(filename));/**
 * Creates a network interface obj using some ephemeral port like 51254
 * @class
 * @extends NetworkInterface
 *
 * Used for dnssd.resolve() functions where you only need to send a query
 * packet, get an answer, and shut down. (Sending packets from port 5353
 * would indicate a fully compliant responder). Packets sent by these interface
 * objects will be treated as 'legacy' queries by other responders.
 */var DisposableInterface=/*#__PURE__*/function(_NetworkInterface){_inherits(DisposableInterface,_NetworkInterface);var _super=_createSuper(DisposableInterface);function DisposableInterface(name,addresses){var _this;_classCallCheck(this,DisposableInterface);debug("Creating new DisposableInterface on ".concat(name,":"));_this=_super.call(this,name);_this._addresses=addresses;return _this;}/**
   * Creates/returns DisposableInterfaces from a name or names of interfaces.
   * Always returns an array of em.
   * @static
   *
   * Ex:
   * > const interfaces = DisposableInterface.createEach('eth0');
   * > const interfaces = DisposableInterface.createEach(['eth0', 'wlan0']);
   *
   * @param  {string|string[]} args
   * @return {DisposableInterface[]}
   */_createClass(DisposableInterface,[{key:"bind",value:function bind(){var _this2=this;return Promise.all(this._addresses.map(function(addr){return _this2._bindSocket(addr);})).then(function(){debug("Interface ".concat(_this2._id," now bound"));_this2._isBound=true;});}},{key:"_bindSocket",value:function _bindSocket(address){var _this3=this;var isPending=true;var promise=new Promise(function(resolve,reject){var socketType=address.family==='IPv6'?'udp6':'udp4';var socket=dgram.createSocket({type:socketType});socket.on('error',function(err){if(isPending)reject(err);else _this3._onError(err);});socket.on('close',function(){_this3._onError(new Error('Socket closed unexpectedly'));});socket.on('message',_this3._onMessage.bind(_this3));socket.on('listening',function(){var sinfo=socket.address();debug("".concat(_this3._id," listening on ").concat(sinfo.address,":").concat(sinfo.port));_this3._sockets.push(socket);resolve();});socket.bind({address:address.address});});return promise.then(function(){isPending=false;});}}],[{key:"create",value:function create(name){var addresses=[{adderss:'0.0.0.0',family:'IPv4'}// {adderss: '::', family: 'IPv6'},
];return name?new DisposableInterface(name,os.networkInterfaces()[name]):new DisposableInterface('INADDR_ANY',addresses);}/**
   * Checks if the names are interfaces that exist in os.networkInterfaces()
   * @static
   *
   * @param  {string|string[]} arg - interface name/names
   * @return {boolean}
   */},{key:"isValidName",value:function isValidName(name){if(!name||typeof name!=='string')return false;return!!~Object.keys(os.networkInterfaces()).indexOf(name);}}]);return DisposableInterface;}(NetworkInterface);module.exports=DisposableInterface;